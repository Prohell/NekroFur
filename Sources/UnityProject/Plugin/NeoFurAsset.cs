using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Serialization;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.IO;
using NeoFurUnityPlugin.VertexFilters;

// This copy of NeoFur for Unity is licensed to anthony.magdelaine@blackantmaster.com

//fix ambig ref
using Debug = UnityEngine.Debug;
using System.Reflection;
using Neoglyphic.NeoFur;

namespace NeoFurUnityPlugin
{
	[AddComponentMenu("NeoFur/NeoFurAsset")]
	public class NeoFurAsset : MonoBehaviour
	{
		MaterialPropertyBlock materialPropertyBlock;

		private Material _mEditMorphMat;
		Material mEditMorphMat
		{
			get
			{
				return _mEditMorphMat ? _mEditMorphMat : _mEditMorphMat = Resources.Load<Material>("EditMorph");
			}
		}

		[SerializeField]
		private NeoFurAssetData mData = new NeoFurAssetData();
		/// <summary>
		/// Fur component's change tracked data items
		/// </summary>
		public NeoFurAssetData data
        {
            get { return mData; }
            set { mData = value; }
        }

		//path to the user supplied fbx file containing fur guides
		public string	mPathToFBX;
        [SerializeField]
        private NeoFur.Data.PreComputedGuideData m_splineGuideData;

        public NeoFur.Data.PreComputedGuideData SplineGuideData
        {
            get
            {
                return m_splineGuideData;
            }
            set
            {
                m_splineGuideData = value;
            }
        }

        //only used for normal guide generation method
        [SerializeField]
        float mGuideLengthPercentage = 1f;
		/// <summary>
		/// Length of guides generated by the normal method
		/// </summary>
		public float GuideLengthPercentage
        {
            get { return mGuideLengthPercentage; }
            set { mGuideLengthPercentage = value; }
        }

		[SerializeField]
		bool	mbUseRendererSettings	=true;
		/// <summary>
		/// Copy the shadowy settings from the display mesh renderer
		/// </summary>
		public bool	useRendererSettings
		{
			get	{return mbUseRendererSettings;}
			set {mbUseRendererSettings = value;}
		}

		[SerializeField]
		ShadowCastingMode mbShadowCastingMode = ShadowCastingMode.On;
		/// <summary>
		/// Fur will cast shadows
		/// </summary>
		public ShadowCastingMode shadowCastingMode
		{
			get {return mbShadowCastingMode; }
			set { mbShadowCastingMode = value;}
		}

		[SerializeField]
		bool	mbRecieveShadows	=true;
		/// <summary>
		/// Fur will recieve shadows
		/// </summary>
		public bool recieveShadows
		{
			get {return mbRecieveShadows;}
			set {mbRecieveShadows = value;}
		}


		//slider values for morph targeted fur guides
		//only used during user adjustment
		[SerializeField]
		[Range(0, 100)]
		private float	[]mMorphWeights;
		public float[] morphWeights
        {
            get { return mMorphWeights; }
            set { mMorphWeights = value; }
        }
		
		[SerializeField]
		[Range(0, 1)]
		private float mNormalDirectionBlend = 1.0f;
		/// <summary>
		/// Normal directional blend amount
		/// </summary>
		public float normalDirectionBlend
        {
            get { return mNormalDirectionBlend; }
            set { mNormalDirectionBlend = value; }
        }

		/* lod parameters */

		[SerializeField]
		private float	mLODStartDist = 5f;
		/// <summary>
		/// LOD start distance
		/// </summary>
		public float LODStartDistance
        {
            get { return mLODStartDist; }
            set { mLODStartDist = value; }
        }

		[SerializeField]
		private float	mLODEndDist = 15f;
		/// <summary>
		/// LOD end distance
		/// </summary>
		public float LODEndDistance
        {
            get { return mLODEndDist; }
            set { mLODEndDist = value; }
        }

		[SerializeField]
		private int		mLODMinShellCount = 3;
		/// <summary>
		/// The number of shells which remain at LOD minimum distance
		/// </summary>
		public int		LODMinimumShellCount
		{
			get {return mLODMinShellCount;}
			set {mLODMinShellCount = value;}
		}

		[SerializeField]
		private float	mMaxCamDist = 60f;
		/// <summary>
		/// Maximum camera distance at which fur is visible
		/// </summary>
		public float	MaximumDistanceFromCamera
		{
			get {return mMaxCamDist;}
			set {mMaxCamDist = value;}
		}

		[SerializeField]
		private float	mShellFade = 1f;
		/// <summary>
		/// Scale for shell fade/taper at ends of fur strands
		/// </summary>
		public float	shellFade
		{
			get {return mShellFade;}
			set {mShellFade = value;}
		}

		[SerializeField]
		private float	mNearCompressionDistance = 0f;
		public float	nearCompressionDistance
		{
			get {return mNearCompressionDistance;}
			set {mNearCompressionDistance = value;}
		}

		[SerializeField]
		private float	mNearCompressionMin = 0.1f;
		public float	nearCompressionMin
		{
			get {return mNearCompressionMin;}
			set {mNearCompressionMin = value;}
		}

		[SerializeField]
		private float	mNearCompressionMax = 1f;
		public float	nearCompressionMax
		{
			get {return mNearCompressionMax;}
			set {mNearCompressionMax = value;}
		}

		[SerializeField]
		private float	mFurLength = 10f;
		/// <summary>
		/// Length of the fur in 1/100th Unity units (centimeters)
		/// </summary>
		public float ShellDistance
        {
            get { return mFurLength; }
            set { mFurLength = value; }
        }

        /// <summary>
        /// Length of fur in Unity Units (meters)
        /// </summary>
        public float ShellDistanceInMeters
        {
            get { return ConvertUnits.ToMeters(mFurLength); }
        }

		[SerializeField]
		private Color	mControlPointDotColor = Color.green;
		/// <summary>
		/// Debug control point dot color
		/// </summary>
		public Color	controlPointDotColor
		{
			get {return mControlPointDotColor;}
			set {mControlPointDotColor = value;}
		}

		[SerializeField]
		private Color	mControlPointRayColor = Color.yellow;
		/// <summary>
		/// Debug control point ray color
		/// </summary>
		public Color	controlPointRayColor
		{
			get {return mControlPointRayColor;}
			set {mControlPointRayColor = value;}
		}

		[SerializeField]
		private float	mControlPointDotSize = 0.005f;
		/// <summary>
		/// Debug control point dot size
		/// </summary>
		public float	 controlPointDotSize
		{
			get {return mControlPointDotSize;}
			set {mControlPointDotSize = value;}
		}

		[SerializeField]
		private Color	mGuideDotColor	= Color.magenta;
		/// <summary>
		/// Debug guide dot color
		/// </summary>
		public Color	guideDotColor
		{
			get {return mGuideDotColor;}
			set {mGuideDotColor = value;}
		}

		[SerializeField]
		private Color	mGuideRayColor	= Color.cyan;
		/// <summary>
		/// Debug guide ray color
		/// </summary>
		public Color	guideRayColor
		{
			get {return mGuideRayColor;}
			set {mGuideRayColor = value;}
		}

		[SerializeField]
		[Range(0.0001f, 0.05f)]
		private float	mGuideDotSize = 0.001f;
		/// <summary>
		/// Debug guide dot size
		/// </summary>
		public float guideDotSize
        {
            get { return mGuideDotSize; }
            set { mGuideDotSize = value; }
        }

		/* physics parameters */

		[SerializeField]
		private PhysicsStuff mPhysParams = new PhysicsStuff();
		/// <summary>
		/// Container for various physics parameters
		/// </summary>
		public PhysicsStuff physParams
        {
            get { return mPhysParams; }
            set { mPhysParams = value; }
        }
		
		float	mLastDeltaTime	=0.0167f;
		float	mCurDeltaTime	=0.0167f;
		public float deltaTime
		{
			get
			{
				return mCurDeltaTime;
			}
		}
		
		public SkinnedMeshRenderer skinnedMeshRenderer
		{
			get
			{
				return renderer as SkinnedMeshRenderer;
			}
		}
		public MeshRenderer meshRenderer
		{
			get
			{
				return renderer as MeshRenderer;
			}
		}

		[SerializeField]
		private Renderer mOverrideRenderer;
		public Renderer overrideRenderer
		{
			get
			{
				return mOverrideRenderer;
			}
			set
			{
				if (!RendererIsSupported(value))
				{
					throw new System.NotSupportedException("overrideRenderer must be either a MeshRenderer or a SkinnedMeshRenderer.");
				}
				mOverrideRenderer = value;
			}
		}

		public bool RendererIsSupported(Renderer renderer)
		{
			return renderer == null || (renderer is MeshRenderer || renderer is SkinnedMeshRenderer);
		}

		private static List<Renderer> rendererCache = new List<Renderer>();
		private Renderer _renderer;
		public new Renderer renderer
		{
			get
			{
				if (overrideRenderer)
				{
					return overrideRenderer;
				}

				if (!_renderer)
				{
					_renderer = null;
					rendererCache.Clear();
					gameObject.GetComponents(rendererCache);
					for (int i = 0; i < rendererCache.Count; i++)
					{
						Renderer r = rendererCache[i];
						if (RendererIsSupported(r))
						{
							_renderer = r;
							break;
						}
					}
				}

				return _renderer;
			}
		}

		private MeshFilter cachedMeshFilter;
		public Mesh rendererMesh
		{
			get
			{
				Renderer r = renderer;
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).sharedMesh;
				}
				else if (r is MeshRenderer)
				{
					if (!cachedMeshFilter || cachedMeshFilter.gameObject != r.gameObject)
					{
						cachedMeshFilter = r.gameObject.GetComponent<MeshFilter>();
					}
					if (!cachedMeshFilter)
					{
						return null;
					}
					return cachedMeshFilter.sharedMesh;
				}
				return null;
			}
		}

		public Mesh mesh
		{
			get
			{
				if (data.overrideGrowthMesh)
				{
					return data.overrideGrowthMesh;
				}
				return rendererMesh;
			}
		}

		public VertexProcessor vertexProcessor { get; private set; }

		//fake wind generator
		//need this because WindZone is all buttoned up
		//and won't give us access to velocity
		internal FakeWind mFakeWind { get; private set; }

		/* debug-related */

		[SerializeField]
		private bool mbDrawGuides;
		/// <summary>
		/// Draw fur guides for debugging?
		/// </summary>
		public bool bDrawGuides
		{
			get {return mbDrawGuides;}
			set {mbDrawGuides = value;}
		}
		
        private float visibleLenScale = 1f;

        public float VisibleLengthScale
        {
            get { return visibleLenScale; }
            set { visibleLenScale = value; }
        }

		private int mLODShellCount;
		/// <summary>
		/// Level of detail fur shell count
		/// </summary>
		public int lodShellCount
		{
			get { return mLODShellCount; }
			set { mLODShellCount = value; }
		}
		
		//material instance used at runtime only
		// Graphics.DrawMesh + instancing + MaterialPropertyBlock is broken in 5.4.
		private Material mMatInstance;

		public Material material
		{
			get
			{
				return mMatInstance;
			}
		}


		void Start()
		{
#if PERSONAL
            if (!Application.isEditor)
                return;
#endif

            if (mData == null)
			{
				return;
			}

			materialPropertyBlock = new MaterialPropertyBlock();

			mFakeWind	=new FakeWind(mData.wind);
			
			if(mesh == null)
			{
				return;
			}

			if(mData.furryMat == null)
			{
				return;
			}

			CreateMaterialInstance();
			
			vertexProcessor = new VertexProcessor(this);
            if (renderer is SkinnedMeshRenderer)
			{
				vertexProcessor.AddFilter<SkinFilter>();
			}
			vertexProcessor.AddFilter<PhysicsFilter>();

			vertexProcessor.Rebuild();
		}

		public void AddRadialForce(RadialForce rf)
		{
			vertexProcessor.GetFilter<PhysicsFilter>().QueueRadialForce(rf);
		}

		//for editor time drawing
		void OnDrawGizmosSelected()
		{
			if(!isActiveAndEnabled)
			{
				return;
			}
            
			if (!mesh)
			{
				return;
			}

			if (vertexProcessor != null)
			{
				vertexProcessor.vertexProcessorDebug.DrawNow(data.bDrawControlPoints, mbDrawGuides);
			}
			
			//draw morphed growth mesh to help user with choices
			if(!Application.isPlaying && mData.guideMethod == NeoFurAssetData.GuideMethod.Morphs)
			{
				Matrix4x4	drawMat	=GetRootBoneTransform();

				Mesh mesh = GetMorphedMesh(morphWeights);

				mEditMorphMat.SetPass(0);
				Graphics.DrawMeshNow(mesh, drawMat);

				DestroyImmediate(mesh);
			}
		}

		void OnDisable()
		{

		}


		void OnDestroy()
		{
			if(mMatInstance != null)
			{
				Destroy(mMatInstance);
            }

			if (vertexProcessor != null)
			{
				vertexProcessor.Dispose();
				vertexProcessor = null;
			}
		}
		
		private Mesh GetMorphedMesh(float[] weights)
		{
			if (mesh.blendShapeCount != weights.Length)
			{
				throw new System.Exception("Blend shape count != weights.Length");
			}

			Mesh newMesh = Instantiate(mesh);

			Vector3[] vertices = newMesh.vertices;
			Vector3[] normals = newMesh.normals;
			Vector4[] tangents = newMesh.tangents;

			Vector3[] deltaVertices = new Vector3[newMesh.vertexCount];
			Vector3[] deltaNormals = normals.Length > 0 ? new Vector3[newMesh.vertexCount] : null;
			Vector3[] deltaTangents = tangents.Length > 0 ? new Vector3[newMesh.vertexCount] : null;

			for (int i = 0; i < weights.Length; i++)
			{
				float weight = weights[i]/100.0f;
				newMesh.GetBlendShapeFrameVertices(i, 0, deltaVertices, deltaNormals, deltaTangents);
				for (int j = 0; j < vertices.Length; j++)
				{
					vertices[j] += deltaVertices[j]*weight;
					if (deltaNormals != null)
					{
						normals[j] += deltaNormals[j]*weight;
					}
					if (deltaTangents != null)
					{
						tangents[j].x += deltaTangents[j].x*weight;
						tangents[j].y += deltaTangents[j].y*weight;
						tangents[j].z += deltaTangents[j].z*weight;
					}
				}
			}

			newMesh.vertices = vertices;
			if (deltaNormals != null)
			{
				newMesh.normals = normals;
			}
			if (deltaTangents != null)
			{
				newMesh.tangents = tangents;
			}

			return newMesh;
		}

		void	Update()
		{

			//see if we are being culled
			if (!renderer || !renderer.isVisible)
			{
				return;
			}

			UpdateTime();

			if(mCurDeltaTime <= 0f)
			{
				return;
			}

			if(mFakeWind != null)
			{
				mFakeWind.Update(mCurDeltaTime);
			}
		}


		//return false if totally out of range
		bool UpdateLOD()
		{
			if(mData.sceneCamera == null)
			{
				lodShellCount	=mData.shellCount;
			}
			else
			{
				Vector3	camRay			=gameObject.transform.position
											- mData.sceneCamera.transform.position;
				float	camDist			=camRay.magnitude;

				if(camDist > mMaxCamDist)
				{
					lodShellCount   =0;
				}
				else if(camDist > mLODEndDist)
				{
					//For this distance, fur needs to shrink away to
					//nothing as the max dist is approached
					lodShellCount   =mLODMinShellCount;

					if(mMaxCamDist > mLODEndDist)
					{
						float	distRelative	=camDist - mLODEndDist;
						visibleLenScale			=1f - (distRelative / (mMaxCamDist - mLODEndDist));
					}
				}
				else if(camDist > mLODStartDist)
				{
					float	lodDist	=mLODEndDist - mLODStartDist;
					float	camLOD	=camDist - mLODStartDist;

					float	lodFactor	=camLOD / lodDist;

					lodShellCount   =(int)Mathf.Lerp((float)mData.shellCount, (float)mLODMinShellCount, lodFactor);
				}
				else
				{
					lodShellCount   =mData.shellCount;
				}

				//cam pos in local space
				Vector3	localCam	=transform.worldToLocalMatrix.MultiplyPoint(
										mData.sceneCamera.transform.position);

				//check for near compression
				float	sqDist	=mesh.bounds.SqrDistance(localCam);
				float	ncDist	=Mathf.Sqrt(sqDist);
				if(ncDist < mNearCompressionDistance)
				{
					visibleLenScale	=Mathf.Lerp(mNearCompressionMin, mNearCompressionMax,
						ncDist / mNearCompressionDistance);

					lodShellCount   =(int)(((float)lodShellCount) * visibleLenScale);
				}
			}

			//set scalar for fur shrinkery
			mMatInstance.SetFloat("_NeoFur_VisibleLengthScale", visibleLenScale);
			
			return	(lodShellCount != 0);
		}


		void LateUpdate()
		{
			//see if we are being culled
			if(!renderer || !renderer.isVisible)
			{
				return;
			}

			//check lod stuff
			if (!UpdateLOD())
			{
				return; //early out here if out of range
			}

			SetFurMaterialParameters();

			vertexProcessor.Process();

			DrawStuff();
		}

		void DrawStuff()
		{
			DrawMeshInstanced();
			
			vertexProcessor.vertexProcessorDebug.Draw(data.bDrawControlPoints, mbDrawGuides);
		}

		private Vector4[] probeCoefficientsCache = new Vector4[7];
		internal void DrawMeshInstanced()
		{
			//shadow settings
			ShadowCastingMode bShadowCastingMode = shadowCastingMode;
			bool bRecieveShadows = mbRecieveShadows;

			if (mbUseRendererSettings && renderer)
			{
				bShadowCastingMode = renderer.shadowCastingMode;
				bRecieveShadows =renderer.receiveShadows;
			}

			Matrix4x4 matrix = renderer.localToWorldMatrix;

			if (drawMeshInstancedMethod != null)
			{
				if (drawMeshInstancedMatrixCache == null || drawMeshInstancedMatrixCache.Length < data.shellCount)
				{
					drawMeshInstancedMatrixCache = new Matrix4x4[Mathf.Min(Mathf.Max(data.shellCount*2, 1), 1024)];
				}

				for (int i = 0; i < lodShellCount; i++)
				{
					drawMeshInstancedMatrixCache[i] = matrix;
				}

				//Have to provide light probe info manually because DrawMeshInstanced doesn't do it automatically.
				SphericalHarmonicsL2 probe = default(SphericalHarmonicsL2);
				if (renderer.probeAnchor)
				{
					LightProbes.GetInterpolatedProbe(renderer.probeAnchor.position, renderer, out probe);
				}
				else
				{
					LightProbes.GetInterpolatedProbe(renderer.transform.position, renderer, out probe);
				}

				for (int i = 0; i < 3; i++)
				{
					probeCoefficientsCache[i].x = probe[i, 3];
					probeCoefficientsCache[i].y = probe[i, 1];
					probeCoefficientsCache[i].z = probe[i, 2];
					probeCoefficientsCache[i].w = probe[i, 0] - probe[i, 6];
				}

				for (int i = 0; i < 3; i++)
				{
					int iPlus3 = i+3;
					probeCoefficientsCache[iPlus3].x = probe[i, 4];
					probeCoefficientsCache[iPlus3].y = probe[i, 5];
					probeCoefficientsCache[iPlus3].z = 3.0f * probe[i, 6];
					probeCoefficientsCache[iPlus3].w = probe[i, 7];
				}

				probeCoefficientsCache[6].x = probe[0, 8];
				probeCoefficientsCache[6].y = probe[1, 8];
				probeCoefficientsCache[6].z = probe[2, 8];
				probeCoefficientsCache[6].w = 1.0f;

				//Unity doesn't like setting these on a material because the names are builtin.
				//Hopefully Unity doesn't break this function in the future too.
				materialPropertyBlock.SetVector("unity_SHAr", probeCoefficientsCache[0]);
				materialPropertyBlock.SetVector("unity_SHAg", probeCoefficientsCache[1]);
				materialPropertyBlock.SetVector("unity_SHAb", probeCoefficientsCache[2]);
				materialPropertyBlock.SetVector("unity_SHBr", probeCoefficientsCache[3]);
				materialPropertyBlock.SetVector("unity_SHBg", probeCoefficientsCache[4]);
				materialPropertyBlock.SetVector("unity_SHBb", probeCoefficientsCache[5]);
				materialPropertyBlock.SetVector("unity_SHC", probeCoefficientsCache[6]);

                //Disabled until motion vectors can be rendered with Draw Mesh Instanced Now func
                materialPropertyBlock.SetFloat("_NeoFur_JitterFrameCount", Time.frameCount*0);

				//This is likely generating garbage because of value type boxing.
				drawMeshInstancedArgumentCache[0] = vertexProcessor.meshResource.value;
				drawMeshInstancedArgumentCache[1] = 0;
				drawMeshInstancedArgumentCache[2] = material;
				drawMeshInstancedArgumentCache[3] = drawMeshInstancedMatrixCache;
				drawMeshInstancedArgumentCache[4] = lodShellCount;
				drawMeshInstancedArgumentCache[5] = materialPropertyBlock;
				drawMeshInstancedArgumentCache[6] = bShadowCastingMode;
				drawMeshInstancedArgumentCache[7] = true;
				drawMeshInstancedArgumentCache[8] = gameObject.layer;
				drawMeshInstancedArgumentCache[9] = null;

				drawMeshInstancedMethod.Invoke(null, drawMeshInstancedArgumentCache);
			}
			else
			{
				//This is only used in 5.4

				//Disabled until motion vectors can be rendered with Draw Mesh Instanced Now func
				mMatInstance.SetFloat("_NeoFur_JitterFrameCount", Time.frameCount*0);

				for (int i = 0; i < lodShellCount; i++)
				{
					materialPropertyBlock.SetFloat("_NeoFur_CurShell", i);
					Graphics.DrawMesh(vertexProcessor.meshResource.value,
						matrix,
						mMatInstance, gameObject.layer,
						null, 0, materialPropertyBlock,
						bShadowCastingMode, bRecieveShadows);
				}
			}
		}

		//from the unreal side
		void UpdateTime()
		{
			// Slide the time delta slowly towards what the actual framerate is.
			const float	MaxTimeDeltaDelta	=0.005f;

			mCurDeltaTime			=Time.deltaTime;
			float	DeltaTimeDelta	=mLastDeltaTime - mCurDeltaTime;
		
			if(Mathf.Abs(DeltaTimeDelta) > MaxTimeDeltaDelta)
			{
				mCurDeltaTime	=mCurDeltaTime + MaxTimeDeltaDelta *
					(DeltaTimeDelta < 0.0f ? -1.0f : 1.0f);
			}
		
			// Clamp our update time. If we're under 30 fps, we're already in bad
			// shape. At least we can keep the simulation stable.
			const float	deltaTimeMax	=(16.667f * 2.0f) / 1000.0f;
			if(mCurDeltaTime > deltaTimeMax)
			{
				mCurDeltaTime	=deltaTimeMax;
			}
			mLastDeltaTime	=mCurDeltaTime;
		}


		Matrix4x4 GetRootBoneTransform()
		{
			if(skinnedMeshRenderer)
			{
				int	rootIndex	=-1;
				Transform[] bones = skinnedMeshRenderer.bones;
				for (int i=0;i < bones.Length;i++)
				{
					if(bones[i] == skinnedMeshRenderer.rootBone)
					{
						rootIndex	=i;
						break;
					}
				}

				Matrix4x4	drawMat	=transform.localToWorldMatrix;
				if(rootIndex != -1 && mesh.bindposes.Length > 0)
				{
					drawMat	=skinnedMeshRenderer.rootBone.localToWorldMatrix*mesh.bindposes[rootIndex];
				}
				return	drawMat;
			}
			return	transform.localToWorldMatrix;
		}
        
		void SetFurMaterialParameters()
		{
			if(mesh == null)
			{
				Debug.LogError("mesh null in SetFurMaterialParameters()");
				return;
			}

			if(mMatInstance == null)
			{
				Debug.LogError("Furry mat null in SetFurMaterialParameters()");
				return;
			}

			mMatInstance.SetFloat("_NeoFur_BendExponent", mPhysParams.Bendiness);
			mMatInstance.SetInt("_NeoFur_ShellCount", lodShellCount);
			mMatInstance.SetInt("_NeoFur_TotalShellCount", mData.shellCount);
			mMatInstance.SetFloat("_NeoFur_ShellDistance", ShellDistanceInMeters);
			mMatInstance.SetFloat("_NeoFur_ShellFade", mShellFade);
			mMatInstance.SetFloat("_NeoFur_NormalDirectionBlend", normalDirectionBlend);
			mMatInstance.SetFloat("_NeoFur_ShellOffset", data.shellOffset);

			vertexProcessor.BindToMaterial(mMatInstance);
		}

		private Matrix4x4[] drawMeshInstancedMatrixCache;
		private static object[] drawMeshInstancedArgumentCache = new object[10];
		private static MethodInfo _drawMeshInstancedMethod;
		private static bool hasCheckedForDrawMeshInstancedMethod;
		private static MethodInfo drawMeshInstancedMethod
		{
			get
			{
				if (!hasCheckedForDrawMeshInstancedMethod)
				{
					try
					{
						_drawMeshInstancedMethod = typeof(Graphics).GetMethod(
						   "DrawMeshInstanced",
						   BindingFlags.Public|BindingFlags.Static|BindingFlags.FlattenHierarchy, null,
						   CallingConventions.Any,
						   new System.Type[] {
							   typeof(Mesh), typeof(int), typeof(Material), typeof(Matrix4x4[]), typeof(int), typeof(MaterialPropertyBlock), typeof(ShadowCastingMode), typeof(bool), typeof(int), typeof(Camera)
						   },
						   null
					   );
					}
					catch (System.Exception)
					{

					}
					hasCheckedForDrawMeshInstancedMethod = true;
				}

				return _drawMeshInstancedMethod;
			}
		}

		private static PropertyInfo _enableInstancingProperty;
		private static bool hasCheckedForEnableInstancingProperty;
		private static PropertyInfo enableInstancingProperty
		{
			get
			{
				if (!hasCheckedForEnableInstancingProperty)
				{
					try
					{
						_enableInstancingProperty = typeof(Material).GetProperty("enableInstancing", BindingFlags.Public|BindingFlags.Instance|BindingFlags.FlattenHierarchy);
					}
					catch (System.Exception)
					{

					}
					hasCheckedForEnableInstancingProperty = true;
				}

				return _enableInstancingProperty;
			}
		}

		//make a material instance so that variables set at update time
		//don't get stomped before draw time, allowing an overall material
		//to be shared by multiple furs
		public void CreateMaterialInstance()
		{
			if(mMatInstance != null)
			{
				Destroy(mMatInstance);
			}

			mMatInstance	=new Material(mData.furryMat);

			if (enableInstancingProperty != null)
			{
				enableInstancingProperty.SetValue(material, true, null);
			}

			mMatInstance.renderQueue += 1;
			
			//set the name to "instance of" to make it clear in the inspector
			mMatInstance.name	="Instance of " + mMatInstance.name;
		}
	}
}
